name: iOS SDK CI (UAT/Production)

on:
  push:
    branches:
      - main
      - release
    paths:
      - 'ios-sdk/**'
      - '.github/workflows/ios-sdk-ci-v2.yml'

  workflow_dispatch:
    inputs:
      force_release:
        description: 'Force release even if tag exists'
        required: false
        type: boolean
        default: false

# ===========================================
# JOB 1: SETUP - Determine version and release type
# ===========================================
jobs:
  setup:
    runs-on: macos-15
    timeout-minutes: 10
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      release_type: ${{ steps.release_type.outputs.type }}
      prerelease: ${{ steps.release_type.outputs.prerelease }}
      should_release: ${{ steps.check_tag.outputs.should_release }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine release type
        id: release_type
        run: |
          BRANCH="${{ github.ref_name }}"
          if [[ "$BRANCH" == "release" ]]; then
            echo "type=production" >> $GITHUB_OUTPUT
            echo "prerelease=false" >> $GITHUB_OUTPUT
            echo "ðŸš€ Release type: PRODUCTION"
          else
            echo "type=uat" >> $GITHUB_OUTPUT
            echo "prerelease=true" >> $GITHUB_OUTPUT
            echo "ðŸ§ª Release type: UAT"
          fi

      - name: Calculate next version
        id: version
        run: |
          echo "ðŸ“¥ Fetching tags from distribution repository..."

          # Debug: show raw git ls-remote output
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "Raw git ls-remote output:"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          RAW_OUTPUT=$(git ls-remote --tags "https://x-access-token:${{ secrets.DISTRIBUTION_REPO_TOKEN }}@github.com/${{ secrets.DISTRIBUTION_REPO }}.git" 2>&1) || true
          echo "$RAW_OUTPUT" | head -30
          echo ""

          # Fetch ALL tags (both production and UAT)
          ALL_TAGS=$(echo "$RAW_OUTPUT" | grep -oE 'v[0-9]+\.[0-9]+\.[0-9]+(-uat)?' | sort -Vu || echo "")

          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ðŸ“‹ All extracted tags:"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          if [ -n "$ALL_TAGS" ]; then
            echo "$ALL_TAGS"
          else
            echo "(no tags found - check DISTRIBUTION_REPO_TOKEN and DISTRIBUTION_REPO secrets)"
          fi
          echo ""

          # Separate production and UAT tags
          PROD_TAGS=$(echo "$ALL_TAGS" | grep -v '\-uat' || echo "")
          UAT_TAGS=$(echo "$ALL_TAGS" | grep '\-uat' || echo "")

          echo "Production tags: ${PROD_TAGS:-none}"
          echo "UAT tags: ${UAT_TAGS:-none}"
          echo ""

          # Find the HIGHEST version across ALL tags (production and UAT)
          # This determines our current version baseline
          HIGHEST_TAG=$(echo "$ALL_TAGS" | sed 's/-uat$//' | sort -V | tail -1)

          if [ -z "$HIGHEST_TAG" ]; then
            HIGHEST_TAG="v1.0.0"
            echo "âš ï¸ No tags found, using default: $HIGHEST_TAG"
          fi

          echo "ðŸ“Œ Highest version found: $HIGHEST_TAG"

          VERSION=${HIGHEST_TAG#v}
          MAJOR=$(echo $VERSION | cut -d. -f1)
          MINOR=$(echo $VERSION | cut -d. -f2)
          PATCH=$(echo $VERSION | cut -d. -f3)
          echo "ðŸ“ Parsed: MAJOR=$MAJOR, MINOR=$MINOR, PATCH=$PATCH"

          RELEASE_TYPE="${{ steps.release_type.outputs.type }}"

          if [[ "$RELEASE_TYPE" == "production" ]]; then
            # Production: increment minor, reset patch
            NEW_MINOR=$((MINOR + 1))
            NEW_VERSION="${MAJOR}.${NEW_MINOR}.0"
            TAG="v${NEW_VERSION}"
            echo ""
            echo "ðŸ“¦ Production release: $TAG"
          else
            # UAT: find highest UAT for this major.minor and increment patch
            UAT_PATTERN="^v${MAJOR}\.${MINOR}\.[0-9]+-uat$"
            echo ""
            echo "ðŸ” Looking for UAT tags matching: v${MAJOR}.${MINOR}.*-uat"

            MATCHING_UAT=$(echo "$ALL_TAGS" | grep -E "$UAT_PATTERN" || echo "")
            if [ -n "$MATCHING_UAT" ]; then
              echo "   Found matching UAT tags:"
              echo "$MATCHING_UAT" | sed 's/^/   - /'
              LAST_UAT_TAG=$(echo "$MATCHING_UAT" | sort -V | tail -1)
            else
              echo "   No UAT tags found for v${MAJOR}.${MINOR}.x"
              LAST_UAT_TAG=""
            fi

            if [ -z "$LAST_UAT_TAG" ]; then
              # No UAT for this version - start at patch+1 or 1
              NEW_PATCH=$((PATCH + 1))
              echo "   Starting new UAT series at patch $NEW_PATCH"
            else
              UAT_PATCH=$(echo ${LAST_UAT_TAG#v} | cut -d. -f3 | cut -d- -f1)
              NEW_PATCH=$((UAT_PATCH + 1))
              echo "   Last UAT: $LAST_UAT_TAG, incrementing to patch $NEW_PATCH"
            fi

            NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
            TAG="v${NEW_VERSION}-uat"
            echo ""
            echo "ðŸ§ª UAT release: $TAG"
          fi

          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ðŸ“¦ FINAL VERSION: $NEW_VERSION"
          echo "ðŸ·ï¸  FINAL TAG: $TAG"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT

      - name: Check if tag exists
        id: check_tag
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          FORCE="${{ inputs.force_release }}"

          echo "ðŸ” Checking if tag $TAG exists in distribution repo..."
          REPO_URL="https://x-access-token:${{ secrets.DISTRIBUTION_REPO_TOKEN }}@github.com/${{ secrets.DISTRIBUTION_REPO }}.git"
          TAG_CHECK=$(git ls-remote --tags "$REPO_URL" "refs/tags/${TAG}" 2>/dev/null || echo "")

          echo "   Result: ${TAG_CHECK:-empty}"

          if [ -n "$TAG_CHECK" ] && [ "$FORCE" != "true" ]; then
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ Tag $TAG already exists, skipping release"
          else
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "âœ… Tag $TAG does not exist, proceeding with release"
          fi

# ===========================================
# JOB 2: TEST - Run tests (parallel with build)
# ===========================================
  test:
    needs: setup
    if: needs.setup.outputs.should_release == 'true'
    runs-on: macos-15
    timeout-minutes: 30

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      - name: Cache for Tests
        uses: actions/cache@v4
        with:
          path: |
            ios-sdk/DerivedData-Tests
            ios-sdk/SourcePackages
            ~/Library/Caches/org.swift.swiftpm
          key: ${{ runner.os }}-test-v2-${{ hashFiles('ios-sdk/src/AriseMobileSdk.xcodeproj/project.pbxproj') }}
          restore-keys: |
            ${{ runner.os }}-test-v2-

      - name: Boot Simulator
        run: |
          SIMULATOR_ID=$(xcrun simctl list devices available | grep "iPhone" | head -1 | sed 's/.*(\([A-F0-9-]*\)).*/\1/')
          xcrun simctl boot "$SIMULATOR_ID" 2>/dev/null || true
          echo "âœ… Simulator ready"

      - name: Run Tests
        run: |
          cd ios-sdk/libs
          chmod +x build_and_test_ci.sh
          ./build_and_test_ci.sh test

      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: ios-sdk/test-results.xcresult
          retention-days: 30
          if-no-files-found: warn

# ===========================================
# JOB 3: BUILD - Build framework (parallel with test)
# ===========================================
  build:
    needs: setup
    if: needs.setup.outputs.should_release == 'true'
    runs-on: macos-15
    timeout-minutes: 30

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      - name: Cache for Build
        uses: actions/cache@v4
        with:
          path: |
            ios-sdk/libs/Build
            ios-sdk/SourcePackages
            ~/Library/Caches/org.swift.swiftpm
          key: ${{ runner.os }}-build-v2-${{ hashFiles('ios-sdk/src/AriseMobileSdk.xcodeproj/project.pbxproj') }}
          restore-keys: |
            ${{ runner.os }}-build-v2-

      - name: Update Info.plist version
        run: |
          PLIST_PATH="ios-sdk/src/AriseMobileSdk/AriseMobileSdk-Info.plist"
          VERSION="${{ needs.setup.outputs.version }}"
          TAG="${{ needs.setup.outputs.tag }}"
          BUILD_NUMBER="${{ github.run_number }}"

          # CFBundleShortVersionString = marketing version (e.g., 1.1.3)
          /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $VERSION" "$PLIST_PATH"

          # CFBundleVersion = build number (incrementing)
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $BUILD_NUMBER" "$PLIST_PATH"

          echo "âœ… Version: $VERSION (build $BUILD_NUMBER)"
          echo "âœ… Tag: $TAG"

      - name: Build XCFramework
        run: |
          cd ios-sdk/libs
          chmod +x build_and_test_ci.sh
          ./build_and_test_ci.sh build
          echo "âœ… Framework built"

      - name: Prepare Distribution
        run: |
          mkdir -p ios-sdk/Distribution/libs

          if [ -d "ios-sdk/libs/AriseMobile.xcframework" ]; then
            cp -R ios-sdk/libs/AriseMobile.xcframework ios-sdk/Distribution/libs/
          fi

          if [ -d "ios-sdk/libs/CloudCommerce.xcframework" ]; then
            cp -R ios-sdk/libs/CloudCommerce.xcframework ios-sdk/Distribution/libs/
          fi

          echo "âœ… Frameworks prepared"
          ls -lh ios-sdk/Distribution/libs/

      - name: Create Archive
        run: |
          cd ios-sdk/Distribution
          VERSION="${{ needs.setup.outputs.version }}"
          TYPE="${{ needs.setup.outputs.release_type }}"

          if [[ "$TYPE" == "uat" ]]; then
            ARCHIVE="AriseMobile-v${VERSION}-uat-xcframeworks.zip"
          else
            ARCHIVE="AriseMobile-v${VERSION}-xcframeworks.zip"
          fi

          zip -r "$ARCHIVE" libs/
          echo "âœ… Archive: $ARCHIVE"

      - name: Upload Build Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ios-sdk-build
          path: ios-sdk/Distribution/
          retention-days: 1

# ===========================================
# JOB 4: RELEASE - Publish (after test + build)
# ===========================================
  release:
    needs: [setup, test, build]
    if: needs.setup.outputs.should_release == 'true'
    runs-on: macos-15
    timeout-minutes: 15

    steps:
      - name: Download Build Artifact
        uses: actions/download-artifact@v4
        with:
          name: ios-sdk-build
          path: distribution-files/

      - name: Setup Distribution Repository
        run: |
          REPO_URL="https://x-access-token:${{ secrets.DISTRIBUTION_REPO_TOKEN }}@github.com/${{ secrets.DISTRIBUTION_REPO }}.git"

          git clone --depth=1 "$REPO_URL" distribution-repo 2>/dev/null || {
            mkdir distribution-repo
            cd distribution-repo
            git init
            git remote add origin "$REPO_URL"
            git checkout -b main
          }

          cd distribution-repo
          git fetch origin --tags 2>/dev/null || true
          git checkout main 2>/dev/null || git checkout -b main

      - name: Configure Git
        working-directory: distribution-repo
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Copy Files
        run: |
          cp distribution-files/Package.swift distribution-repo/ 2>/dev/null || true
          cp distribution-files/README.md distribution-repo/ 2>/dev/null || true

          mkdir -p distribution-repo/Sources
          cp -R distribution-files/Sources/* distribution-repo/Sources/ 2>/dev/null || true

          mkdir -p distribution-repo/libs
          rm -rf distribution-repo/libs/*
          cp -R distribution-files/libs/* distribution-repo/libs/

          echo "âœ… Files copied"

      - name: Commit and Push
        working-directory: distribution-repo
        run: |
          git add .

          if git diff --staged --quiet; then
            echo "No changes"
          else
            TYPE="${{ needs.setup.outputs.release_type }}"
            VERSION="${{ needs.setup.outputs.version }}"

            if [[ "$TYPE" == "uat" ]]; then
              git commit -m "UAT release v${VERSION}"
            else
              git commit -m "Production release v${VERSION}"
            fi
            git push -u origin main
            echo "âœ… Pushed"
          fi

      - name: Create Tag
        working-directory: distribution-repo
        run: |
          TAG="${{ needs.setup.outputs.tag }}"
          TYPE="${{ needs.setup.outputs.release_type }}"

          if git rev-parse "$TAG" >/dev/null 2>&1; then
            git tag -d "$TAG"
          fi

          if git ls-remote --tags origin "refs/tags/${TAG}" | grep -q .; then
            echo "âš ï¸ Tag $TAG already exists remotely, skipping"
          else
            if [[ "$TYPE" == "uat" ]]; then
              git tag -a "$TAG" -m "UAT Release $TAG"
            else
              git tag -a "$TAG" -m "Production Release $TAG"
            fi

            git push origin "$TAG"
            echo "âœ… Tag $TAG created"
          fi

      - name: Find Archive
        id: archive
        run: |
          ARCHIVE=$(ls distribution-files/*.zip 2>/dev/null | head -1)
          echo "path=$ARCHIVE" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Archive: $ARCHIVE"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          repository: ${{ secrets.DISTRIBUTION_REPO }}
          token: ${{ secrets.DISTRIBUTION_REPO_TOKEN }}
          tag_name: ${{ needs.setup.outputs.tag }}
          name: AriseMobileSdk ${{ needs.setup.outputs.tag }}
          prerelease: ${{ needs.setup.outputs.prerelease }}
          body: |
            ## AriseMobileSdk ${{ needs.setup.outputs.tag }}

            **Type:** ${{ needs.setup.outputs.release_type == 'uat' && 'ðŸ§ª UAT' || 'âœ… Production' }}

            ### Installation

            ```swift
            .package(url: "https://github.com/${{ secrets.DISTRIBUTION_REPO }}.git", ${{ needs.setup.outputs.release_type == 'uat' && format('exact: "{0}-uat"', needs.setup.outputs.version) || format('from: "{0}"', needs.setup.outputs.version) }})
            ```
          files: ${{ steps.archive.outputs.path }}
          draft: false

      - name: Summary
        run: |
          echo "## âœ… Release Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Type | ${{ needs.setup.outputs.release_type }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Version | ${{ needs.setup.outputs.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Tag | ${{ needs.setup.outputs.tag }} |" >> $GITHUB_STEP_SUMMARY
