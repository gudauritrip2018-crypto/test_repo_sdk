name: Deploy iOS SDK Release

on:
  workflow_dispatch:
    inputs:
      release_notes_file:
        description: 'Path to release notes file (leave empty to auto-generate from commits)'
        required: false
        type: string
        default: ''
      run_tests:
        description: 'Run tests before release'
        required: false
        type: boolean
        default: false

jobs:
  setup:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      changelog: ${{ steps.changelog.outputs.changelog }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.DISTRIBUTION_APP_ID }}
          private-key: ${{ secrets.DISTRIBUTION_APP_PRIVATE_KEY }}
          owner: ${{ secrets.DISTRIBUTION_REPO_OWNER }}
          repositories: ${{ secrets.DISTRIBUTION_REPO_NAME }}

      - name: Extract version from branch name
        id: version
        run: |
          BRANCH="${{ github.ref_name }}"
          echo "Branch: $BRANCH"

          if [[ "$BRANCH" =~ ^release/([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
            VERSION="${BASH_REMATCH[1]}"
            TAG="v${VERSION}"

            echo "Version: $VERSION"
            echo "Tag: $TAG"

            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "tag=$TAG" >> $GITHUB_OUTPUT
          else
            echo "Error: Branch name must be in format 'release/X.Y.Z'"
            echo "Current branch: $BRANCH"
            exit 1
          fi

      - name: Generate changelog
        id: changelog
        env:
          DIST_REPO_TOKEN: ${{ steps.app-token.outputs.token }}
          DIST_REPO: ${{ secrets.DISTRIBUTION_REPO }}
        run: |
          REPO_URL="https://x-access-token:${DIST_REPO_TOKEN}@github.com/${DIST_REPO}.git"
          NOTES_FILE="${{ inputs.release_notes_file }}"

          # Use file only if path is provided AND file exists AND has content
          USE_FILE=false
          if [ -n "$NOTES_FILE" ] && [ -f "$NOTES_FILE" ] && [ -s "$NOTES_FILE" ]; then
            USE_FILE=true
          fi

          if [ "$USE_FILE" = true ]; then
            echo "Reading release notes from: $NOTES_FILE"
            CHANGELOG=$(cat "$NOTES_FILE")
          else
            echo "No release notes file provided or file is empty, generating from commits since last release..."

            # Find the last release tag from distribution repo
            LAST_TAG=""
            if git clone --bare --filter=blob:none "$REPO_URL" dist-repo-tags 2>/dev/null; then
              cd dist-repo-tags
              # Get production tags (exclude pre-release), sort by version, get the latest
              LAST_TAG=$(git tag -l "v*" | grep -v "pre-release" | sort -V | tail -1)
              cd ..
              rm -rf dist-repo-tags
            fi

            if [ -n "$LAST_TAG" ]; then
              echo "Last release tag: $LAST_TAG"
              # Clone and get tag date with proper error handling
              LAST_TAG_DATE=""
              if git clone --bare --filter=blob:none "$REPO_URL" dist-repo-date 2>/dev/null; then
                LAST_TAG_DATE=$(cd dist-repo-date && git log -1 --format="%ci" "$LAST_TAG" 2>/dev/null || echo "")
                rm -rf dist-repo-date
              else
                echo "Warning: Failed to clone repo for tag date"
              fi

              if [ -n "$LAST_TAG_DATE" ]; then
                echo "Last release date: $LAST_TAG_DATE"
                CHANGELOG=$(git log --since="$LAST_TAG_DATE" --pretty=format:"- %s (%h)" --no-merges -- ios-sdk/)
              else
                echo "Could not get last tag date, using last 20 commits"
                CHANGELOG=$(git log --pretty=format:"- %s (%h)" --no-merges -- ios-sdk/ -20)
              fi
            else
              echo "No previous release tags found, using last 20 commits"
              CHANGELOG=$(git log --pretty=format:"- %s (%h)" --no-merges -- ios-sdk/ -20)
            fi

            if [ -z "$CHANGELOG" ]; then
              CHANGELOG="- Release ${{ steps.version.outputs.version }}"
            fi
          fi

          echo "Changelog:"
          echo "$CHANGELOG"

          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  test:
    needs: setup
    if: inputs.run_tests == true
    runs-on: macos-15
    timeout-minutes: 60

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      - name: Cache for Tests
        uses: actions/cache@v4
        with:
          path: |
            ios-sdk/DerivedData-Tests
            ios-sdk/SourcePackages
            ~/Library/Caches/org.swift.swiftpm
          key: ${{ runner.os }}-test-v2-${{ hashFiles('ios-sdk/src/AriseMobileSdk.xcodeproj/project.pbxproj') }}
          restore-keys: |
            ${{ runner.os }}-test-v2-

      - name: Boot Simulator
        run: |
          # Extract simulator ID with validation
          SIMULATOR_LINE=$(xcrun simctl list devices available | grep "iPhone" | head -1)
          if [ -z "$SIMULATOR_LINE" ]; then
            echo "Error: No iPhone simulator found"
            exit 1
          fi

          SIMULATOR_ID=$(echo "$SIMULATOR_LINE" | grep -oE '[A-F0-9]{8}-[A-F0-9]{4}-[A-F0-9]{4}-[A-F0-9]{4}-[A-F0-9]{12}')
          if [ -z "$SIMULATOR_ID" ]; then
            echo "Error: Could not extract simulator ID from: $SIMULATOR_LINE"
            exit 1
          fi

          echo "Booting simulator: $SIMULATOR_ID"
          xcrun simctl boot "$SIMULATOR_ID" 2>/dev/null || true
          echo "Simulator ready"

      - name: Run Tests
        run: |
          cd ios-sdk/libs
          chmod +x build_and_test_ci.sh
          ./build_and_test_ci.sh test

      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: ios-sdk/test-results.xcresult
          retention-days: 30
          if-no-files-found: warn

  build:
    needs: setup
    runs-on: macos-15
    timeout-minutes: 30

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      - name: Cache for Build
        uses: actions/cache@v4
        with:
          path: |
            ios-sdk/libs/Build
            ios-sdk/SourcePackages
            ~/Library/Caches/org.swift.swiftpm
          key: ${{ runner.os }}-build-v2-${{ hashFiles('ios-sdk/src/AriseMobileSdk.xcodeproj/project.pbxproj') }}
          restore-keys: |
            ${{ runner.os }}-build-v2-

      - name: Build XCFramework
        env:
          MARKETING_VERSION: ${{ needs.setup.outputs.version }}
          BUILD_NUMBER: ${{ github.run_number }}
        run: |
          cd ios-sdk/libs
          chmod +x build_and_test_ci.sh
          echo "Building with version: ${MARKETING_VERSION}"
          ./build_and_test_ci.sh build
          echo "Framework built"

      - name: Prepare Distribution
        run: |
          mkdir -p ios-sdk/Distribution/libs

          if [ -d "ios-sdk/libs/ARISE.xcframework" ]; then
            cp -R ios-sdk/libs/ARISE.xcframework ios-sdk/Distribution/libs/
          fi

          if [ -d "ios-sdk/libs/CloudCommerce.xcframework" ]; then
            cp -R ios-sdk/libs/CloudCommerce.xcframework ios-sdk/Distribution/libs/
          fi

          echo "Frameworks prepared"
          ls -lh ios-sdk/Distribution/libs/

      - name: Create Archive
        run: |
          cd ios-sdk/Distribution
          VERSION="${{ needs.setup.outputs.version }}"
          ARCHIVE="AriseMobileSdk-v${VERSION}-xcframeworks.zip"
          zip -r "$ARCHIVE" libs/
          echo "Archive: $ARCHIVE"

      - name: Upload Build Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ios-sdk-build
          path: ios-sdk/Distribution/
          retention-days: 1

  release:
    needs: [setup, test, build]
    if: always() && needs.setup.result == 'success' && needs.build.result == 'success' && (needs.test.result == 'success' || needs.test.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.DISTRIBUTION_APP_ID }}
          private-key: ${{ secrets.DISTRIBUTION_APP_PRIVATE_KEY }}
          owner: ${{ secrets.DISTRIBUTION_REPO_OWNER }}
          repositories: ${{ secrets.DISTRIBUTION_REPO_NAME }}

      - name: Download Build Artifact
        uses: actions/download-artifact@v4
        with:
          name: ios-sdk-build
          path: distribution-files/

      - name: Setup Distribution Repository
        env:
          GIT_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          REPO_URL="https://x-access-token:${GIT_TOKEN}@github.com/${{ secrets.DISTRIBUTION_REPO }}.git"

          git clone "$REPO_URL" distribution-repo 2>/dev/null || {
            mkdir distribution-repo
            cd distribution-repo
            git init
            git remote add origin "$REPO_URL"
          }

          cd distribution-repo
          git fetch origin --tags 2>/dev/null || true

          if git ls-remote --heads origin release | grep -q release; then
            git checkout release
            git pull origin release
          else
            git checkout -b release
          fi

      - name: Configure Git
        working-directory: distribution-repo
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Copy Files
        run: |
          cp distribution-files/Package.swift distribution-repo/ 2>/dev/null || true
          cp distribution-files/README.md distribution-repo/ 2>/dev/null || true

          mkdir -p distribution-repo/Sources
          cp -R distribution-files/Sources/* distribution-repo/Sources/ 2>/dev/null || true

          mkdir -p distribution-repo/libs
          rm -rf distribution-repo/libs/*
          cp -R distribution-files/libs/* distribution-repo/libs/

          echo "Files copied"

      - name: Commit and Push
        working-directory: distribution-repo
        run: |
          git add .

          if git diff --staged --quiet; then
            echo "No changes"
          else
            VERSION="${{ needs.setup.outputs.version }}"
            git commit -m "Release v${VERSION}"

            # Pull with rebase to handle concurrent pushes, then push with retry
            MAX_RETRIES=3
            for i in $(seq 1 $MAX_RETRIES); do
              git pull --rebase origin release 2>/dev/null || true
              if git push -u origin release; then
                echo "Pushed successfully"
                break
              fi
              if [ $i -eq $MAX_RETRIES ]; then
                echo "Failed to push after $MAX_RETRIES attempts"
                exit 1
              fi
              echo "Push failed, retrying ($i/$MAX_RETRIES)..."
              sleep 2
            done
          fi

      - name: Create Tag
        working-directory: distribution-repo
        run: |
          TAG="${{ needs.setup.outputs.tag }}"

          # Delete local tag if exists
          git tag -d "$TAG" 2>/dev/null || true

          # Atomic tag creation: create and push, handle failure gracefully
          git tag -a "$TAG" -m "Release $TAG"
          if git push origin "$TAG" 2>&1; then
            echo "Tag $TAG created"
          else
            echo "Tag $TAG already exists or push failed, skipping"
            git tag -d "$TAG" 2>/dev/null || true
          fi

      - name: Find Archive
        id: archive
        run: |
          # Find zip files with validation
          ARCHIVE=$(find distribution-files -maxdepth 1 -name "*.zip" -type f 2>/dev/null | head -1)

          if [ -z "$ARCHIVE" ] || [ ! -f "$ARCHIVE" ]; then
            echo "Error: No zip archive found in distribution-files/"
            ls -la distribution-files/ || true
            exit 1
          fi

          echo "path=$ARCHIVE" >> $GITHUB_OUTPUT
          echo "Archive: $ARCHIVE"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          repository: ${{ secrets.DISTRIBUTION_REPO }}
          token: ${{ steps.app-token.outputs.token }}
          tag_name: ${{ needs.setup.outputs.tag }}
          name: AriseMobileSdk ${{ needs.setup.outputs.tag }}
          prerelease: false
          body: |
            ## AriseMobileSdk ${{ needs.setup.outputs.tag }}

            **Type:** Production Release

            ### Changes

            ${{ needs.setup.outputs.changelog }}

            ### Installation

            ```swift
            .package(url: "https://github.com/${{ secrets.DISTRIBUTION_REPO }}.git", from: "${{ needs.setup.outputs.version }}")
            ```
          files: ${{ steps.archive.outputs.path }}
          draft: false

      - name: Summary
        run: |
          echo "## Release Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Version | ${{ needs.setup.outputs.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Tag | ${{ needs.setup.outputs.tag }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Branch | release |" >> $GITHUB_STEP_SUMMARY
